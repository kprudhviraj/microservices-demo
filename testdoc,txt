# Business Process Management Framework Documentation

## Introduction

The Business Process Management (BPM) Framework is designed to simplify and manage complex business processes by breaking them down into multiple, manageable tasks. This framework allows for any business process to be integrated and handled efficiently, making it adaptable to a wide range of use cases. By utilizing this framework, businesses can automate, monitor, and optimize their processes to achieve greater efficiency and consistency.

## Architecture

The architecture of the Business Process Management (BPM) Framework is designed to be modular and flexible, allowing it to handle various business processes efficiently. The key components of the architecture include:

1. **Process Engine**: The core of the framework that manages the execution of business processes, ensuring that tasks are performed in the correct order and according to the defined rules.
2. **Task Manager**: Responsible for handling individual tasks within a process. It ensures that each task is executed correctly and monitors its progress.
3. **Rule Engine**: A component that applies business rules and logic to tasks. It validates and enriches data based on predefined rules.
4. **Workflow Designer**: A user interface that allows business analysts to design and configure business processes visually. It enables the creation and modification of workflows without requiring coding.
5. **Data Repository**: Stores all process definitions, task details, and execution logs. It provides a central place for data management and retrieval.
6. **Integration Layer**: Facilitates communication with external systems and services, allowing the framework to interact with other business applications and data sources.

## Classes

### Business Process Engine

The **Business Process Engine** is the core class responsible for executing workflows. It has the following key method:

- **executeWorkflow**: This method takes two inputs:
  - **Business Process**: The definition of the business process to be executed. A business process is a group of steps that need to be performed in a specific sequence.
  - **Context**: The data context within which the business process operates.

This method orchestrates the execution of the business process by leveraging the provided context and the defined process steps.

### BusinessProcess

The **BusinessProcess** class is responsible for defining and managing the structure of a business process. It includes the following key attributes:

- **Steps**: A list of steps that make up the business process.
- **Priority Sequence**: An order or priority that dictates the sequence in which the steps should be executed. If no priority is set, the steps will be executed in their natural order, from one to the total number of steps.

This class ensures that the business process is executed in the correct order according to the defined priority sequence or in a sequential order if no priority is specified.

### CalculatorDefinitionFile

The **CalculatorDefinitionFile** is an enumeration that defines the structure of the business processes. It uses the builder pattern to create and organize the steps and priorities of a business process. Key aspects include:

- **Enum Name**: Represents the name of the specific business process, such as `BALANCE_API`.
- **Business Process Instance**: Each enum entry holds an instance of a `BusinessProcess`, which is created using the builder pattern. This pattern allows for a fluent and flexible way to define the process.

Example usage:
- `new BusinessProcess().addStep(step1).addStep(step2).setPriority(priority)`: This method chain creates the steps and sets their priorities within the business process.

Additionally, the **CalculatorDefinitionFile** provides a lookup functionality:
- **lookupByName**: This method takes the name of a context as input and returns the corresponding structure and workflow for that context.

This enumeration provides a structured and standardized way to define various business processes within the framework and includes a convenient method for retrieving process definitions by name.

### Step Interface

The **Step** interface defines the structure for each step within a business process. Since a business process consists of a list of steps, this interface ensures that each step adheres to a specific contract. Key aspects of the **Step** interface include:

- **evaluate**: A method that takes the context as input and returns a boolean. This method checks preconditions to determine if the step should be executed.
- **executeTasks**: A method that takes the context as input and executes all the tasks associated with the step.
- **getPriority**: A method that returns the priority of the step, which is used to determine the order of execution within the business process.
- **setPriority**: A method that sets the priority of the step.
- **compareTo**: A method that allows steps to be sorted based on their priority.

This interface provides a standardized way to define the behavior and requirements of each step in a business process, ensuring consistency and flexibility in how steps are implemented, executed, and prioritized.

### BasicStep

The **BasicStep** class implements the **Step** interface and provides a concrete implementation for the steps within a business process. It includes the following key attributes and methods:

- **priority**: An integer representing the priority of the step.
- **predicate**: A condition that needs to be satisfied for the step to be executed.

Key methods:
- **evaluate**: This method takes the context as input and evaluates the predicate condition. It returns a boolean indicating whether the step should be executed.
- **executeTasks**: This method takes the context as input and executes all the tasks associated with the step.
- **getPriority**: Returns the priority of the step.
- **setPriority**: Sets the priority of the step.
- **compareTo**: Allows steps to be sorted based on their priority.

The **BasicStep** class ensures that each step is executed based on its priority and only when its predicate condition is satisfied.

### SequentialTaskExecutionStep

The **SequentialTaskExecutionStep** class extends from **BasicStep** and provides functionality for executing a list of tasks in a sequential manner. It includes the following key attributes and methods:

- **tasks**: A list of tasks that need to be executed sequentially.

Key methods:
- **evaluate**: Inherited from **BasicStep**, this method takes the context as input and evaluates the predicate condition to determine if the step should be executed.
- **executeTasks**: This method takes the context as input and executes each task in the list sequentially.
- **getPriority**: Inherited from **BasicStep**, this method returns the priority of the step.
- **setPriority**: Inherited from **BasicStep**, this method sets the priority of the step.
- **compareTo**: Inherited from **BasicStep**, this method allows steps to be sorted based on their priority.

The **SequentialTaskExecutionStep** class ensures that all tasks within the step are executed in order, maintaining the sequence defined in the list of tasks.

### ParallelTaskExecutionStep

The **ParallelTaskExecutionStep** class extends from **BasicStep** and provides functionality for executing a list of tasks in parallel. It includes the following key attributes and methods:

- **tasks**: A list of tasks that need to be executed in parallel.

Key methods:
- **evaluate**: Inherited from **BasicStep**, this method takes the context as input and evaluates the predicate condition to determine if the step should be executed.
- **executeTasks**: This method takes the context as input and executes each task in the list concurrently.
- **getPriority**: Inherited from **BasicStep**, this method returns the priority of the step.
- **setPriority**: Inherited from **BasicStep**, this method sets the priority of the step.
- **compareTo**: Inherited from **BasicStep**, this method allows steps to be sorted based on their priority.

The **ParallelTaskExecutionStep** class ensures that all tasks within the step are executed simultaneously, allowing for more efficient processing when tasks can be run concurrently.

### StepBuilder

The **StepBuilder** class implements the builder pattern for creating steps within a business process. This class provides a flexible way to define the structure and type of each step, allowing for either sequential or parallel task execution.

Key methods:
- **addStep**: Adds a step to the builder with a specified predicate condition and priority.
- **setPriority**: Sets the priority for the current step being built.
- **setPredicate**: Defines the predicate condition for the step.
- **buildSequential**: Finalizes the creation of the step as a **SequentialTaskExecutionStep**, organizing tasks to be executed in order.
- **buildParallel**: Finalizes the creation of the step as a **ParallelTaskExecutionStep**, organizing tasks to be executed concurrently.

Usage example:
```java
StepBuilder builder = new StepBuilder();
builder.addStep(step1).setPredicate(predicate1).setPriority(priority1).buildSequential();

The StepBuilder class ensures that steps are created in a consistent and structured manner, with the flexibility to specify whether tasks within each step are executed sequentially or in parallel.

Task
The Task class is the fundamental element within the system, as each step comprises one or more tasks. It includes the following key method:

execute: This method takes the context as input, performs the task, and does not return anything. However, it can throw an exception if an error occurs during execution.
The Task class provides a standardized way to define and implement the individual actions that make up the steps in a business process.

BaseCalculator
The BaseCalculator class is an abstract class that implements the Task interface. It serves as a base class for tasks that involve calculations and validations. Key aspects of the BaseCalculator class include:

execute: Inherited from the Task interface, this method takes the context as input. It retrieves parameters from the context, performs necessary validations, and then calls an abstract method for further processing.
abstractMethod: An abstract method that subclasses must implement. This method can have any number of parameters derived from the context, allowing for flexible and specific calculations.
The BaseCalculator class ensures that common validation logic is centralized, while allowing subclasses to define specific calculation logic through the abstract method.

Rule Engine
The Rule Engine is a component that resides within specific tasks, responsible for applying business rules and logic for data validation and enrichment. It is not directly tied to the overall business process or individual steps but is embedded within tasks where specific validations or data enrichment are needed.

Key Features
Context Evaluation: The Rule Engine evaluates the context provided to determine which rules apply within the task.
Rule Application: It applies the relevant rules to the task, modifying or validating data as necessary.
Task Integration: The Rule Engine operates within tasks to ensure that each task adheres to the specified business logic and data requirements.
Flexibility: Allows for dynamic rule definitions within tasks, enabling easy updates and modifications without changing the core process definitions.
Usage
Precondition Checks: Used within a task to evaluate preconditions, ensuring that all necessary criteria are met before proceeding.
Data Enrichment: Enriches the context with additional data or computed values required for task execution.
Validation: Performs validations within tasks to ensure that the data meets the required standards and business rules.

